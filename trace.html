<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>SVG 路径手动描摹工具</title>
    <style>
      :root {
        --bg: #0b0d10;
        --panel: #131720;
        --panel-2: #0f131b;
        --text: #e8eef7;
        --muted: #9fb0c7;
        --accent: #5aa9ff;
        --danger: #ff6b6b;
        --ok: #32d296;
        --border: #1f2633;
      }
      html, body {
        height: 100%;
      }
      body {
        margin: 0;
        background: var(--bg);
        color: var(--text);
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen,
        Ubuntu, Cantarell, 'Fira Sans', 'Droid Sans', 'Helvetica Neue', Arial, sans-serif;
      }
      .toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
        padding: 12px 16px;
        border-bottom: 1px solid var(--border);
        background: linear-gradient(180deg, var(--panel), var(--panel-2));
        position: sticky;
        top: 0;
        z-index: 5;
      }
      .toolbar label {
        font-size: 12px;
        color: var(--muted);
        margin-right: 6px;
      }
      .toolbar .group {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        border: 1px solid var(--border);
        border-radius: 10px;
        background: #0e1117;
      }
      input[type="range"] {
        accent-color: var(--accent);
      }
      input[type="number"] {
        width: 64px;
        background: #0b0f16;
        color: var(--text);
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 4px 6px;
      }
      button {
        background: #172031;
        color: var(--text);
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 8px 12px;
        cursor: pointer;
      }
      button:hover {
        border-color: #2a3447;
      }
      button.primary {
        background: #163155;
        border-color: #1e3f70;
      }
      button.danger {
        background: #3a1717;
        border-color: #5a1f1f;
        color: #ffdede;
      }
      .layout {
        display: grid;
        grid-template-columns: 1fr 360px;
        gap: 14px;
        padding: 14px;
      }
      .stage-wrap {
        position: relative;
        border: 1px solid var(--border);
        border-radius: 12px;
        overflow: hidden;
        background: #0a0d12;
      }
      .stage {
        position: relative;
        width: 100%;
        height: 55vh;
        background: #0a0d12;
      }
      canvas, svg {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        display: block;
      }
      #maskCanvas { pointer-events: none; }
      #svgOverlay { pointer-events: none; }
      #svgOverlay.editing { pointer-events: auto; }
      .side {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 12px;
        background: #0e131b;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      textarea {
        width: 100%;
        min-height: 140px;
        resize: vertical;
        background: #0b0f16;
        color: var(--text);
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 8px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size: 12px;
      }
      .hint {
        color: var(--muted);
        font-size: 12px;
      }
      .legend {
        display: flex;
        gap: 12px;
        align-items: center;
        color: var(--muted);
        font-size: 12px;
      }
      .swatch { width: 12px; height: 12px; border-radius: 2px; display: inline-block; }
      .sw1 { background: #67d2ff; }
      .sw2 { background: #ffd166; }
      .sw3 { background: #ff6b6b; }
      .sw4 { background: #32d296; }
    </style>
  </head>
  <body>
    <div class="toolbar">
      <div class="group">
        <label>图片</label>
        <input id="fileInput" type="file" accept="image/*">
        <button id="fitBtn">适配窗口</button>
      </div>
      <div class="group">
        <label>黑色阈值</label>
        <input id="threshold" type="range" min="0" max="255" value="120">
        <input id="thresholdNum" type="number" min="0" max="255" value="120">
        <label><input id="showMask" type="checkbox" checked> 显示掩膜</label>
      </div>
      <div class="group">
        <label><input id="snapEnabled" type="checkbox" checked> 吸附黑色</label>
        <label>半径</label>
        <input id="snapRadius" type="number" min="1" max="20" step="1" value="4">
      </div>
      <div class="group">
        <label>简化(ε)</label>
        <input id="epsilon" type="range" min="0" max="10" step="0.1" value="1.8">
        <input id="epsilonNum" type="number" min="0" max="10" step="0.1" value="1.8">
        <label>采样半径</label>
        <input id="sampleRadius" type="number" min="0" max="8" step="1" value="1">
      </div>
      <div class="group">
        <label><input id="smoothPreview" type="checkbox"> 贝塞尔平滑</label>
        <label>张力</label>
        <input id="smoothTension" type="number" min="0" max="2" step="0.1" value="1.0">
      </div>
      <div class="group">
        <button id="editToggle">进入编辑</button>
        <button id="undoBtn">撤销</button>
        <button id="redoBtn">重做</button>
        <button id="clearBtn" class="danger">清空</button>
      </div>
      <div class="group">
        <button id="exportBtn" class="primary">导出 SVG</button>
      </div>
      <div class="group">
        <label>画布高度</label>
        <input id="stageHeight" type="range" min="30" max="100" value="55">
        <span id="stageHeightVal" style="color: var(--muted); font-size: 12px;">55vh</span>
      </div>
      <div class="group">
        <label>自动识别</label>
        <button id="autoSkeletonBtn">自动骨架(β)</button>
        <label>缩放</label>
        <input id="autoScale" type="number" min="0.1" max="1" step="0.05" value="0.5">
        <label>最小点数</label>
        <input id="autoMinPoints" type="number" min="4" max="9999" step="1" value="20">
      </div>
    </div>
    <div class="layout">
      <div class="stage-wrap">
        <div id="stage" class="stage">
          <canvas id="imageCanvas"></canvas>
          <canvas id="maskCanvas"></canvas>
          <svg id="svgOverlay"></svg>
        </div>
      </div>
      <div class="side">
        <div class="legend">
          <span class="swatch sw1"></span><span>描摹路径</span>
          <span class="swatch sw2"></span><span>控制点</span>
          <span class="swatch sw3"></span><span>选择中</span>
          <span class="swatch sw4"></span><span>可绘制区域</span>
        </div>
        <div class="hint">提示：按住并拖动鼠标在黑色区域上绘制；点击“进入编辑”后可以拖动控制点。编辑模式下：Alt/Option+单击控制点删除；双击路径添加控制点。</div>
        <textarea id="pathText" readonly placeholder="当前选中路径的 SVG path 数据"></textarea>
      </div>
    </div>
    <script>
      const fileInput = document.getElementById('fileInput');
      const stage = document.getElementById('stage');
      const imageCanvas = document.getElementById('imageCanvas');
      const maskCanvas = document.getElementById('maskCanvas');
      const svg = document.getElementById('svgOverlay');
      const thresholdRange = document.getElementById('threshold');
      const thresholdNum = document.getElementById('thresholdNum');
      const showMask = document.getElementById('showMask');
      const epsilonRange = document.getElementById('epsilon');
      const epsilonNum = document.getElementById('epsilonNum');
      const sampleRadiusInput = document.getElementById('sampleRadius');
      const fitBtn = document.getElementById('fitBtn');
      const undoBtn = document.getElementById('undoBtn');
      const redoBtn = document.getElementById('redoBtn');
      const clearBtn = document.getElementById('clearBtn');
      const exportBtn = document.getElementById('exportBtn');
      const editToggle = document.getElementById('editToggle');
      const pathText = document.getElementById('pathText');
      const snapEnabled = document.getElementById('snapEnabled');
      const snapRadiusInput = document.getElementById('snapRadius');
      const smoothPreview = document.getElementById('smoothPreview');
      const smoothTension = document.getElementById('smoothTension');
      const stageHeight = document.getElementById('stageHeight');
      const stageHeightVal = document.getElementById('stageHeightVal');
      const autoSkeletonBtn = document.getElementById('autoSkeletonBtn');
      const autoScale = document.getElementById('autoScale');
      const autoMinPoints = document.getElementById('autoMinPoints');

      const imgCtx = imageCanvas.getContext('2d');
      const maskCtx = maskCanvas.getContext('2d');

      let deviceRatio = Math.max(1, window.devicePixelRatio || 1);
      let imageBitmapObj = null;
      let naturalWidth = 0, naturalHeight = 0;
      // Cached device-pixel buffers for fast/accurate sampling
      let cachedImgData = null; // ImageData of entire canvas at device resolution
      let deviceW = 0, deviceH = 0;
      let drawing = false;
      let currentPathPoints = [];
      let paths = []; // { id, points: [{x,y}], pathEl, pointsGroup }
      let selectedPathId = null;
      let history = []; // stack of JSON snapshots
      let redoStack = [];

      function stageSize() {
        const rect = stage.getBoundingClientRect();
        return { width: rect.width, height: rect.height };
      }

      function resizeCanvases() {
        const { width, height } = stageSize();
        const w = Math.max(1, Math.floor(width));
        const h = Math.max(1, Math.floor(height));
        for (const c of [imageCanvas, maskCanvas]) {
          c.width = Math.floor(w * deviceRatio);
          c.height = Math.floor(h * deviceRatio);
          c.style.width = w + 'px';
          c.style.height = h + 'px';
          const ctx = c.getContext('2d');
          ctx.setTransform(deviceRatio, 0, 0, deviceRatio, 0, 0);
        }
        svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
        svg.setAttribute('width', w);
        svg.setAttribute('height', h);
        redrawAll();
      }

      function loadFromFile(file) {
        if (!file) return;
        const url = URL.createObjectURL(file);
        createImageBitmap(file).then(bmp => {
          imageBitmapObj = bmp;
          naturalWidth = bmp.width;
          naturalHeight = bmp.height;
          fitToStage();
          URL.revokeObjectURL(url);
        }).catch(err => console.error(err));
      }

      function fitToStage() {
        const { width: sw, height: sh } = stageSize();
        if (!imageBitmapObj) { clearCanvas(); return; }
        const ir = imageBitmapObj.width / imageBitmapObj.height;
        const sr = sw / sh;
        let dw = sw, dh = sh;
        if (ir > sr) {
          dw = sw; dh = Math.floor(dw / ir);
        } else {
          dh = sh; dw = Math.floor(dh * ir);
        }
        clearCanvas();
        const dx = Math.floor((sw - dw) / 2);
        const dy = Math.floor((sh - dh) / 2);
        imgCtx.drawImage(imageBitmapObj, dx, dy, dw, dh);
        capturePixelsAndMask();
      }

      function clearCanvas() {
        imgCtx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
        maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
      }

      function capturePixelsAndMask() {
        // Capture device-resolution pixels of the image canvas
        deviceW = imageCanvas.width;
        deviceH = imageCanvas.height;
        cachedImgData = imgCtx.getImageData(0, 0, deviceW, deviceH);
        drawMask();
      }

      function drawMask() {
        const { width, height } = stageSize();
        maskCtx.clearRect(0, 0, width, height);
        if (!showMask.checked || !cachedImgData) { return; }
        // Clone so we do not mutate the cache
        const imgData = new ImageData(new Uint8ClampedArray(cachedImgData.data), deviceW, deviceH);
        const data = imgData.data;
        const th = getThreshold();
        for (let i = 0; i < data.length; i += 4) {
          const r = data[i], g = data[i + 1], b = data[i + 2];
          const lum = 0.2126 * r + 0.7152 * g + 0.0722 * b; // 0..255
          const dark = 255 - lum; // 0..255
          if (dark >= th) {
            data[i] = 50; data[i + 1] = 200; data[i + 2] = 130; data[i + 3] = 90; // greenish overlay
          } else {
            data[i + 3] = 0;
          }
        }
        // putImageData uses device pixels; our canvas is already device-scaled
        maskCtx.putImageData(imgData, 0, 0);
      }

      function getThreshold() { return Number(thresholdNum.value || thresholdRange.value); }
      function getEpsilon() { return Number(epsilonNum.value || epsilonRange.value); }
      function getSampleRadius() { return Number(sampleRadiusInput.value); }

      function isDarkAt(x, y) {
        const { width, height } = stageSize();
        if (x < 0 || y < 0 || x >= width || y >= height) return false;
        if (!cachedImgData) return false;
        const th = getThreshold();
        const rCss = getSampleRadius();
        const rDev = Math.max(0, Math.round(rCss * deviceRatio));
        const bx = Math.min(deviceW - 1, Math.max(0, Math.floor(x * deviceRatio)));
        const by = Math.min(deviceH - 1, Math.max(0, Math.floor(y * deviceRatio)));
        if (rDev <= 0) {
          const i = 4 * (by * deviceW + bx);
          const pr = cachedImgData.data[i], pg = cachedImgData.data[i + 1], pb = cachedImgData.data[i + 2];
          const lum = 0.2126 * pr + 0.7152 * pg + 0.0722 * pb;
          return (255 - lum) >= th;
        }
        let sum = 0, count = 0;
        for (let oy = -rDev; oy <= rDev; oy++) {
          const yy = by + oy;
          if (yy < 0 || yy >= deviceH) continue;
          for (let ox = -rDev; ox <= rDev; ox++) {
            const xx = bx + ox;
            if (xx < 0 || xx >= deviceW) continue;
            const idx = 4 * (yy * deviceW + xx);
            const r = cachedImgData.data[idx], g = cachedImgData.data[idx + 1], b = cachedImgData.data[idx + 2];
            const lum = 0.2126 * r + 0.7152 * g + 0.0722 * b;
            sum += (255 - lum);
            count++;
          }
        }
        const darkAvg = sum / Math.max(1, count);
        return darkAvg >= th;
      }

      function pointerToStage(evt) {
        const rect = stage.getBoundingClientRect();
        const x = evt.clientX - rect.left;
        const y = evt.clientY - rect.top;
        return { x, y };
      }

      function beginPathAt(p) {
        currentPathPoints = [p];
        drawing = true;
      }

      function addPointIfAllowed(p) {
        if (!isDarkAt(p.x, p.y)) return; // restrict to dark areas
        const last = currentPathPoints[currentPathPoints.length - 1];
        const dx = p.x - last.x, dy = p.y - last.y;
        if (dx * dx + dy * dy < 2.5) return; // skip very close points
        currentPathPoints.push(p);
        drawDraftPath(currentPathPoints);
      }

      function endPath() {
        drawing = false;
        if (currentPathPoints.length < 2) { currentPathPoints = []; return; }
        const simplified = rdp(currentPathPoints, getEpsilon());
        const id = 'p' + Date.now() + Math.random().toString(16).slice(2);
        const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke', '#67d2ff');
        path.setAttribute('stroke-width', '2.2');
        path.setAttribute('vector-effect', 'non-scaling-stroke');
        path.dataset.id = id;
        group.appendChild(path);
        svg.appendChild(group);
        const record = { id, points: simplified, pathEl: path, groupEl: group };
        paths.push(record);
        updatePathElement(record);
        selectPath(id);
        pushHistory();
        currentPathPoints = [];
        clearDraft();
      }

      // Draft drawing using a temporary polyline path
      let draftPathEl = null;
      function drawDraftPath(points) {
        if (!draftPathEl) {
          draftPathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          draftPathEl.setAttribute('fill', 'none');
          draftPathEl.setAttribute('stroke', '#ffd166');
          draftPathEl.setAttribute('stroke-width', '1.6');
          draftPathEl.setAttribute('vector-effect', 'non-scaling-stroke');
          svg.appendChild(draftPathEl);
        }
        draftPathEl.setAttribute('d', toPathD(points));
      }
      function clearDraft() {
        if (draftPathEl && draftPathEl.parentNode) draftPathEl.parentNode.removeChild(draftPathEl);
        draftPathEl = null;
      }

      function toPathD(points) {
        if (!points.length) return '';
        let d = `M ${points[0].x.toFixed(1)} ${points[0].y.toFixed(1)}`;
        for (let i = 1; i < points.length; i++) {
          const p = points[i];
          d += ` L ${p.x.toFixed(1)} ${p.y.toFixed(1)}`;
        }
        return d;
      }

      function updatePathElement(rec) {
        rec.pathEl.setAttribute('d', toPathDForDisplay(rec));
      }

      function toPathDForDisplay(rec) {
        if (smoothPreview && smoothPreview.checked) {
          const t = Number(smoothTension.value || 1);
          return toBezierD(rec.points, t);
        }
        return toPathD(rec.points);
      }

      function selectPath(id) {
        selectedPathId = id;
        updateSelectionStyles();
        updateHandles();
        updatePathText();
      }

      function deselectPath() {
        selectedPathId = null;
        updateSelectionStyles();
        removeHandles();
        updatePathText();
      }

      function updateSelectionStyles() {
        paths.forEach(rec => {
          if (rec.id === selectedPathId) {
            rec.pathEl.setAttribute('stroke', '#ff6b6b');
          } else {
            rec.pathEl.setAttribute('stroke', '#67d2ff');
          }
        });
      }

      function updateHandles() {
        removeHandles();
        if (!selectedPathId) return;
        const rec = paths.find(p => p.id === selectedPathId);
        if (!rec) return;
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.dataset.handleFor = rec.id;
        rec.groupEl.appendChild(g);
        rec.points.forEach((pt, idx) => {
          const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          c.setAttribute('cx', pt.x);
          c.setAttribute('cy', pt.y);
          c.setAttribute('r', '4');
          c.setAttribute('fill', '#ffd166');
          c.setAttribute('stroke', '#2a2f3a');
          c.setAttribute('stroke-width', '1');
          c.style.cursor = 'grab';
          c.dataset.index = String(idx);
          c.addEventListener('pointerdown', onHandlePointerDown);
          g.appendChild(c);
        });
        svg.classList.add('editing');
      }

      function removeHandles() {
        svg.classList.remove('editing');
        paths.forEach(rec => {
          const children = Array.from(rec.groupEl.children);
          for (const el of children) {
            if (el !== rec.pathEl) rec.groupEl.removeChild(el);
          }
        });
      }

      function updatePathText() {
        if (!selectedPathId) { pathText.value = ''; return; }
        const rec = paths.find(p => p.id === selectedPathId);
        if (!rec) { pathText.value = ''; return; }
        pathText.value = rec.pathEl.getAttribute('d') || '';
      }

      // --- Ramer–Douglas–Peucker simplification ---
      function rdp(points, epsilon) {
        if (!epsilon || epsilon <= 0 || points.length < 3) return points.slice();
        const dmaxRes = findDmax(points);
        if (dmaxRes.maxDist > epsilon) {
          const rec1 = rdp(points.slice(0, dmaxRes.index + 1), epsilon);
          const rec2 = rdp(points.slice(dmaxRes.index), epsilon);
          return rec1.slice(0, -1).concat(rec2);
        } else {
          return [points[0], points[points.length - 1]];
        }
      }
      function perpendicularDistance(p, p1, p2) {
        const x = p.x, y = p.y;
        const x1 = p1.x, y1 = p1.y;
        const x2 = p2.x, y2 = p2.y;
        const A = x - x1, B = y - y1, C = x2 - x1, D = y2 - y1;
        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        let param = lenSq !== 0 ? dot / lenSq : -1;
        let xx, yy;
        if (param < 0) { xx = x1; yy = y1; }
        else if (param > 1) { xx = x2; yy = y2; }
        else { xx = x1 + param * C; yy = y1 + param * D; }
        const dx = x - xx, dy = y - yy;
        return Math.sqrt(dx * dx + dy * dy);
      }
      function findDmax(points) {
        let index = 0; let maxDist = 0;
        for (let i = 1; i < points.length - 1; i++) {
          const d = perpendicularDistance(points[i], points[0], points[points.length - 1]);
          if (d > maxDist) { index = i; maxDist = d; }
        }
        return { index, maxDist };
      }

      // --- Catmull-Rom to Cubic Bezier ---
      function toBezierD(points, tension) {
        const n = points.length;
        if (n === 0) return '';
        if (n === 1) return `M ${points[0].x.toFixed(1)} ${points[0].y.toFixed(1)}`;
        const t = Math.max(0, Number.isFinite(tension) ? tension : 1.0);
        let d = `M ${points[0].x.toFixed(1)} ${points[0].y.toFixed(1)}`;
        for (let i = 0; i < n - 1; i++) {
          const p0 = points[Math.max(0, i - 1)];
          const p1 = points[i];
          const p2 = points[i + 1];
          const p3 = points[Math.min(n - 1, i + 2)];
          const c1x = p1.x + (p2.x - p0.x) / 6 * t;
          const c1y = p1.y + (p2.y - p0.y) / 6 * t;
          const c2x = p2.x - (p3.x - p1.x) / 6 * t;
          const c2y = p2.y - (p3.y - p1.y) / 6 * t;
          d += ` C ${c1x.toFixed(1)} ${c1y.toFixed(1)}, ${c2x.toFixed(1)} ${c2y.toFixed(1)}, ${p2.x.toFixed(1)} ${p2.y.toFixed(1)}`;
        }
        return d;
      }

      // --- Snap to nearest dark pixel ---
      function snapToDark(p) {
        if (!snapEnabled || !snapEnabled.checked || !cachedImgData) return p;
        const radiusCss = Number(snapRadiusInput.value || 0);
        const rDev = Math.max(1, Math.round(radiusCss * deviceRatio));
        const bx = Math.min(deviceW - 1, Math.max(0, Math.round(p.x * deviceRatio)));
        const by = Math.min(deviceH - 1, Math.max(0, Math.round(p.y * deviceRatio)));
        const th = getThreshold();
        let best = null; // {x,y,dist2,dark}
        for (let oy = -rDev; oy <= rDev; oy++) {
          const yy = by + oy;
          if (yy < 0 || yy >= deviceH) continue;
          for (let ox = -rDev; ox <= rDev; ox++) {
            const xx = bx + ox;
            if (xx < 0 || xx >= deviceW) continue;
            const i = 4 * (yy * deviceW + xx);
            const r = cachedImgData.data[i], g = cachedImgData.data[i + 1], b = cachedImgData.data[i + 2];
            const lum = 0.2126 * r + 0.7152 * g + 0.0722 * b;
            const dark = 255 - lum;
            if (dark < th) continue;
            const dx = xx - bx, dy = yy - by;
            const dist2 = dx * dx + dy * dy;
            if (!best || dist2 < best.dist2 || (dist2 === best.dist2 && dark > best.dark)) {
              best = { x: xx, y: yy, dist2, dark };
            }
          }
        }
        if (!best) return p;
        return { x: best.x / deviceRatio, y: best.y / deviceRatio };
      }

      // --- History ---
      function snapshot() {
        return JSON.stringify(paths.map(rec => ({ id: rec.id, points: rec.points })));
      }
      function restore(json) {
        const arr = JSON.parse(json);
        // clear SVG
        svg.innerHTML = '';
        paths = [];
        for (const p of arr) {
          const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
          const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          path.setAttribute('fill', 'none');
          path.setAttribute('stroke', '#67d2ff');
          path.setAttribute('stroke-width', '2.2');
          path.setAttribute('vector-effect', 'non-scaling-stroke');
          path.dataset.id = p.id;
          group.appendChild(path);
          svg.appendChild(group);
          const rec = { id: p.id, points: p.points, pathEl: path, groupEl: group };
          paths.push(rec);
          updatePathElement(rec);
        }
        if (paths.length) selectPath(paths[paths.length - 1].id); else deselectPath();
      }
      function pushHistory() {
        history.push(snapshot());
        if (history.length > 200) history.shift();
        redoStack = [];
      }
      function undo() {
        if (!history.length) return;
        const current = snapshot();
        redoStack.push(current);
        const state = history.pop();
        if (history.length) restore(history[history.length - 1]);
        else { restore('[]'); }
      }
      function redo() {
        if (!redoStack.length) return;
        const state = redoStack.pop();
        history.push(state);
        restore(state);
      }

      // --- Export ---
      function exportSVG() {
        const { width, height } = stageSize();
        const doc = [`<?xml version="1.0" encoding="UTF-8"?>`,
          `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">`,
          `<g fill="none" stroke="#000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">`];
        for (const rec of paths) {
          const d = toPathDForDisplay(rec);
          doc.push(`<path d="${d}"/>`);
        }
        doc.push(`</g></svg>`);
        const blob = new Blob([doc.join('\n')], { type: 'image/svg+xml' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'traced.svg';
        document.body.appendChild(a);
        a.click();
        URL.revokeObjectURL(a.href);
        a.remove();
      }

      function redrawAll() {
        // redraw background image into resized canvas
        if (imageBitmapObj) fitToStage();
        // paths remain as SVG overlay (already scaled by viewBox)
        drawMask();
      }

      // --- Auto skeletonization (beta) ---
      // Downscale + threshold + connected-component contour sampling into paths
      function runAutoSkeleton() {
        if (!cachedImgData) return;
        const scale = Math.max(0.1, Math.min(1, Number(autoScale.value) || 0.5));
        const w = Math.max(4, Math.floor(deviceW * scale));
        const h = Math.max(4, Math.floor(deviceH * scale));
        const th = getThreshold();
        const grid = new Uint8Array(w * h);
        // nearest downsample and binarize
        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            const sx = Math.min(deviceW - 1, Math.floor(x / scale));
            const sy = Math.min(deviceH - 1, Math.floor(y / scale));
            const i = 4 * (sy * deviceW + sx);
            const r = cachedImgData.data[i], g = cachedImgData.data[i + 1], b = cachedImgData.data[i + 2];
            const lum = 0.2126 * r + 0.7152 * g + 0.0722 * b;
            const dark = 255 - lum;
            grid[y * w + x] = dark >= th ? 1 : 0;
          }
        }
        // Connected components (4-neighborhood)
        const visited = new Uint8Array(w * h);
        const components = [];
        const q = [];
        const dirs = [1, 0, -1, 0, 1];
        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            const idx = y * w + x;
            if (!grid[idx] || visited[idx]) continue;
            q.length = 0; q.push(x, y); visited[idx] = 1;
            const comp = [];
            while (q.length) {
              const cy = q.pop();
              const cx = q.pop();
              comp.push([cx, cy]);
              for (let k = 0; k < 4; k++) {
                const nx = cx + dirs[k];
                const ny = cy + dirs[k + 1];
                if (nx < 0 || ny < 0 || nx >= w || ny >= h) continue;
                const nIdx = ny * w + nx;
                if (grid[nIdx] && !visited[nIdx]) { visited[nIdx] = 1; q.push(nx, ny); }
              }
            }
            components.push(comp);
          }
        }
        const minPts = Math.max(4, Number(autoMinPoints.value) || 20);
        for (const comp of components) {
          if (comp.length < minPts) continue;
          // Order points roughly around centroid by angle to form contour
          let cx = 0, cy = 0;
          for (const [px, py] of comp) { cx += px; cy += py; }
          cx /= comp.length; cy /= comp.length;
          comp.sort((a, b) => Math.atan2(a[1] - cy, a[0] - cx) - Math.atan2(b[1] - cy, b[0] - cx));
          // Downsample to reasonable number of vertices
          const step = Math.max(1, Math.floor(comp.length / Math.max(minPts, 40)));
          const pts = [];
          for (let i = 0; i < comp.length; i += step) {
            const [px, py] = comp[i];
            pts.push({ x: (px / scale) / deviceRatio, y: (py / scale) / deviceRatio });
          }
          if (pts.length >= 2) {
            const simplified = rdp(pts, getEpsilon());
            const id = 'auto' + Date.now() + Math.random().toString(16).slice(2);
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke', '#67d2ff');
            path.setAttribute('stroke-width', '2.2');
            path.setAttribute('vector-effect', 'non-scaling-stroke');
            path.dataset.id = id;
            group.appendChild(path);
            svg.appendChild(group);
            const record = { id, points: simplified, pathEl: path, groupEl: group };
            paths.push(record);
            updatePathElement(record);
          }
        }
        if (paths.length) { selectPath(paths[paths.length - 1].id); pushHistory(); }
      }

      // --- Events ---
      fileInput.addEventListener('change', e => loadFromFile(fileInput.files && fileInput.files[0]));
      fitBtn.addEventListener('click', fitToStage);
      thresholdRange.addEventListener('input', () => { thresholdNum.value = thresholdRange.value; drawMask(); });
      thresholdNum.addEventListener('input', () => { thresholdRange.value = thresholdNum.value; drawMask(); });
      epsilonRange.addEventListener('input', () => { epsilonNum.value = epsilonRange.value; });
      epsilonNum.addEventListener('input', () => { epsilonRange.value = epsilonNum.value; });
      showMask.addEventListener('change', () => drawMask());
      window.addEventListener('resize', () => { resizeCanvases(); fitToStage(); });
      stageHeight.addEventListener('input', () => {
        const val = Number(stageHeight.value);
        stage.style.height = val + 'vh';
        stageHeightVal.textContent = val + 'vh';
        // Wait a frame to let layout settle, then resize canvases and refit
        requestAnimationFrame(() => { resizeCanvases(); fitToStage(); });
      });

      stage.addEventListener('pointerdown', e => {
        let p = pointerToStage(e);
        p = snapToDark(p);
        if (svg.classList.contains('editing')) return; // editing mode uses handles
        if (!isDarkAt(p.x, p.y)) return; // only start on dark (after snap)
        stage.setPointerCapture(e.pointerId);
        beginPathAt(p);
      });
      stage.addEventListener('pointermove', e => {
        if (!drawing) return;
        const p = snapToDark(pointerToStage(e));
        addPointIfAllowed(p);
      });
      stage.addEventListener('pointerup', e => {
        if (!drawing) return;
        endPath();
        stage.releasePointerCapture(e.pointerId);
      });
      stage.addEventListener('pointerleave', () => { if (drawing) endPath(); });

      // Select path by clicking it
      svg.addEventListener('pointerdown', e => {
        const target = e.target;
        if (target.tagName === 'path' && target.dataset.id) {
          selectPath(target.dataset.id);
        }
      });
      svg.addEventListener('dblclick', onSvgDblClick);

      function onHandlePointerDown(e) {
        e.stopPropagation();
        const circle = e.currentTarget;
        const index = Number(circle.dataset.index);
        const rec = paths.find(p => p.id === selectedPathId);
        if (!rec) return;
        // Alt/Option + click to delete point
        if (e.altKey) {
          if (rec.points.length <= 2) {
            // remove entire path if deleting would make it invalid
            rec.groupEl.remove();
            const i = paths.findIndex(p => p.id === rec.id);
            if (i >= 0) paths.splice(i, 1);
            deselectPath();
            pushHistory();
            return;
          }
          rec.points.splice(index, 1);
          updatePathElement(rec);
          removeHandles();
          updateHandles();
          updatePathText();
          pushHistory();
          return;
        }
        const onMove = (ev) => {
          const p = pointerToStage(ev);
          rec.points[index] = p;
          circle.setAttribute('cx', p.x);
          circle.setAttribute('cy', p.y);
          updatePathElement(rec);
          updatePathText();
        };
        const onUp = () => {
          window.removeEventListener('pointermove', onMove);
          window.removeEventListener('pointerup', onUp);
          pushHistory();
        };
        window.addEventListener('pointermove', onMove);
        window.addEventListener('pointerup', onUp, { once: true });
      }

      // Add point by double-clicking a path (editing mode)
      function onSvgDblClick(e) {
        const target = e.target;
        if (!svg.classList.contains('editing')) return;
        if (!(target && target.tagName === 'path' && target.dataset.id)) return;
        const rec = paths.find(p => p.id === target.dataset.id);
        if (!rec) return;
        const p = pointerToStage(e);
        insertPointIntoPath(rec, p);
      }

      function insertPointIntoPath(rec, p) {
        if (!rec.points || rec.points.length < 2) return;
        // Find nearest segment in polyline
        let bestIdx = 1; // insert before bestIdx
        let bestDist2 = Infinity;
        for (let i = 1; i < rec.points.length; i++) {
          const a = rec.points[i - 1];
          const b = rec.points[i];
          const d2 = pointToSegmentDist2(p, a, b);
          if (d2 < bestDist2) { bestDist2 = d2; bestIdx = i; }
        }
        rec.points.splice(bestIdx, 0, p);
        updatePathElement(rec);
        removeHandles();
        updateHandles();
        updatePathText();
        pushHistory();
      }

      function pointToSegmentDist2(p, a, b) {
        const vx = b.x - a.x, vy = b.y - a.y;
        const wx = p.x - a.x, wy = p.y - a.y;
        const c1 = vx * wx + vy * wy;
        if (c1 <= 0) return (p.x - a.x) ** 2 + (p.y - a.y) ** 2;
        const c2 = vx * vx + vy * vy;
        if (c2 <= c1) return (p.x - b.x) ** 2 + (p.y - b.y) ** 2;
        const t = c1 / c2;
        const px = a.x + t * vx;
        const py = a.y + t * vy;
        return (p.x - px) ** 2 + (p.y - py) ** 2;
      }

      undoBtn.addEventListener('click', () => { undo(); });
      redoBtn.addEventListener('click', () => { redo(); });
      clearBtn.addEventListener('click', () => {
        paths = [];
        svg.innerHTML = '';
        deselectPath();
        pushHistory();
      });
      exportBtn.addEventListener('click', exportSVG);
      smoothPreview.addEventListener('change', () => { paths.forEach(updatePathElement); updatePathText(); });
      smoothTension.addEventListener('input', () => { if (smoothPreview.checked) { paths.forEach(updatePathElement); updatePathText(); } });
      autoSkeletonBtn.addEventListener('click', runAutoSkeleton);
      editToggle.addEventListener('click', () => {
        if (svg.classList.contains('editing')) {
          svg.classList.remove('editing');
          editToggle.textContent = '进入编辑';
          removeHandles();
        } else {
          svg.classList.add('editing');
          editToggle.textContent = '退出编辑';
          if (selectedPathId) updateHandles();
        }
      });

      // Init
      resizeCanvases();
      drawMask();
      pushHistory();
    </script>
  </body>
</html>


